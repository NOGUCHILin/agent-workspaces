import { devices, type Browser, type Page, type Frame, type Locator } from 'playwright-core';
import type { LaunchCommand } from './types.js';
import { type RefMap, type EnhancedSnapshot } from './snapshot.js';
interface TrackedRequest {
    url: string;
    method: string;
    headers: Record<string, string>;
    timestamp: number;
    resourceType: string;
}
interface ConsoleMessage {
    type: string;
    text: string;
    timestamp: number;
}
interface PageError {
    message: string;
    timestamp: number;
}
/**
 * Manages the Playwright browser lifecycle with multiple tabs/windows
 */
export declare class BrowserManager {
    private browser;
    private contexts;
    private pages;
    private activePageIndex;
    private activeFrame;
    private dialogHandler;
    private trackedRequests;
    private routes;
    private consoleMessages;
    private pageErrors;
    private isRecordingHar;
    private refMap;
    private lastSnapshot;
    private scopedHeaderRoutes;
    /**
     * Check if browser is launched
     */
    isLaunched(): boolean;
    /**
     * Get enhanced snapshot with refs and cache the ref map
     */
    getSnapshot(options?: {
        interactive?: boolean;
        maxDepth?: number;
        compact?: boolean;
        selector?: string;
    }): Promise<EnhancedSnapshot>;
    /**
     * Get the cached ref map from last snapshot
     */
    getRefMap(): RefMap;
    /**
     * Get a locator from a ref (e.g., "e1", "@e1", "ref=e1")
     * Returns null if ref doesn't exist or is invalid
     */
    getLocatorFromRef(refArg: string): Locator | null;
    /**
     * Check if a selector looks like a ref
     */
    isRef(selector: string): boolean;
    /**
     * Get locator - supports both refs and regular selectors
     */
    getLocator(selectorOrRef: string): Locator;
    /**
     * Get the current active page, throws if not launched
     */
    getPage(): Page;
    /**
     * Get the current frame (or page's main frame if no frame is selected)
     */
    getFrame(): Frame;
    /**
     * Switch to a frame by selector, name, or URL
     */
    switchToFrame(options: {
        selector?: string;
        name?: string;
        url?: string;
    }): Promise<void>;
    /**
     * Switch back to main frame
     */
    switchToMainFrame(): void;
    /**
     * Set up dialog handler
     */
    setDialogHandler(response: 'accept' | 'dismiss', promptText?: string): void;
    /**
     * Clear dialog handler
     */
    clearDialogHandler(): void;
    /**
     * Start tracking requests
     */
    startRequestTracking(): void;
    /**
     * Get tracked requests
     */
    getRequests(filter?: string): TrackedRequest[];
    /**
     * Clear tracked requests
     */
    clearRequests(): void;
    /**
     * Add a route to intercept requests
     */
    addRoute(url: string, options: {
        response?: {
            status?: number;
            body?: string;
            contentType?: string;
            headers?: Record<string, string>;
        };
        abort?: boolean;
    }): Promise<void>;
    /**
     * Remove a route
     */
    removeRoute(url?: string): Promise<void>;
    /**
     * Set geolocation
     */
    setGeolocation(latitude: number, longitude: number, accuracy?: number): Promise<void>;
    /**
     * Set permissions
     */
    setPermissions(permissions: string[], grant: boolean): Promise<void>;
    /**
     * Set viewport
     */
    setViewport(width: number, height: number): Promise<void>;
    /**
     * Get device descriptor
     */
    getDevice(deviceName: string): (typeof devices)[keyof typeof devices] | undefined;
    /**
     * List available devices
     */
    listDevices(): string[];
    /**
     * Start console message tracking
     */
    startConsoleTracking(): void;
    /**
     * Get console messages
     */
    getConsoleMessages(): ConsoleMessage[];
    /**
     * Clear console messages
     */
    clearConsoleMessages(): void;
    /**
     * Start error tracking
     */
    startErrorTracking(): void;
    /**
     * Get page errors
     */
    getPageErrors(): PageError[];
    /**
     * Clear page errors
     */
    clearPageErrors(): void;
    /**
     * Start HAR recording
     */
    startHarRecording(): Promise<void>;
    /**
     * Check if HAR recording
     */
    isHarRecording(): boolean;
    /**
     * Set offline mode
     */
    setOffline(offline: boolean): Promise<void>;
    /**
     * Set extra HTTP headers (global - all requests)
     */
    setExtraHeaders(headers: Record<string, string>): Promise<void>;
    /**
     * Set scoped HTTP headers (only for requests matching the origin)
     * Uses route interception to add headers only to matching requests
     */
    setScopedHeaders(origin: string, headers: Record<string, string>): Promise<void>;
    /**
     * Clear scoped headers for an origin (or all if no origin specified)
     */
    clearScopedHeaders(origin?: string): Promise<void>;
    /**
     * Start tracing
     */
    startTracing(options: {
        screenshots?: boolean;
        snapshots?: boolean;
    }): Promise<void>;
    /**
     * Stop tracing and save
     */
    stopTracing(path: string): Promise<void>;
    /**
     * Save storage state (cookies, localStorage, etc.)
     */
    saveStorageState(path: string): Promise<void>;
    /**
     * Get all pages
     */
    getPages(): Page[];
    /**
     * Get current page index
     */
    getActiveIndex(): number;
    /**
     * Get the current browser instance
     */
    getBrowser(): Browser | null;
    /**
     * Launch the browser with the specified options
     * If already launched, this is a no-op (browser stays open)
     */
    launch(options: LaunchCommand): Promise<void>;
    /**
     * Set up console and error tracking for a page
     */
    private setupPageTracking;
    /**
     * Create a new tab in the current context
     */
    newTab(): Promise<{
        index: number;
        total: number;
    }>;
    /**
     * Create a new window (new context)
     */
    newWindow(viewport?: {
        width: number;
        height: number;
    }): Promise<{
        index: number;
        total: number;
    }>;
    /**
     * Switch to a specific tab/page by index
     */
    switchTo(index: number): {
        index: number;
        url: string;
        title: string;
    };
    /**
     * Close a specific tab/page
     */
    closeTab(index?: number): Promise<{
        closed: number;
        remaining: number;
    }>;
    /**
     * List all tabs with their info
     */
    listTabs(): Promise<Array<{
        index: number;
        url: string;
        title: string;
        active: boolean;
    }>>;
    /**
     * Close the browser and clean up
     */
    close(): Promise<void>;
}
export {};
//# sourceMappingURL=browser.d.ts.map